<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Posts Tagged - Kubernetes | Scott Cranton &mdash; Solo.io Customer Success </title>
    <meta property="og:title" content="Posts Tagged - Kubernetes | Scott Cranton &mdash; Solo.io Customer Success " />
    <meta name="twitter:title" content="Posts Tagged - Kubernetes | Scott Cranton &mdash; Solo.io Customer Success " />

    <meta name="description" content="I lead Customer Success at Solo.io. I enjoy hacking tech, and writing about it.">
    <meta name="description" property="og:description" content="I lead Customer Success at Solo.io. I enjoy hacking tech, and writing about it." />
    <meta name="twitter:description" content="I lead Customer Success at Solo.io. I enjoy hacking tech, and writing about it." />

    <meta name="twitter:card" content="summary_large_image" />
    
    <meta name="twitter:site" content="@scottcranton" />
    
    <meta property="og:url" content="https://scott.cranton.com/tag/Kubernetes/" />

    <meta property="og:image" content="" />
    <meta name="twitter:image" content="" />

    <meta name="author" content="Scott Cranton" />

    <meta name="copyright" content="Copyright by Scott Cranton. All Rights Reserved." />

    <style>
        @font-face {
            font-family: 'Roboto';
            font-style: normal;
            font-weight: 300;
            src: local('Roboto Light'), local('Roboto-Light'), url(https://fonts.gstatic.com/s/roboto/v15/Hgo13k-tfSpn0qi1SFdUfVtXRa8TVwTICgirnJhmVJw.woff2) format('woff2');
            unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
        }

        @font-face {
            font-family: 'Roboto';
            font-style: normal;
            font-weight: 400;
            src: local('Roboto'), local('Roboto-Regular'), url(https://fonts.gstatic.com/s/roboto/v15/CWB0XYA8bzo0kSThX0UTuA.woff2) format('woff2');
            unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
        }

        @font-face {
            font-family: 'Roboto';
            font-style: normal;
            font-weight: 700;
            src: local('Roboto Bold'), local('Roboto-Bold'), url(https://fonts.gstatic.com/s/roboto/v15/d-6IYplOFocCacKzxwXSOFtXRa8TVwTICgirnJhmVJw.woff2) format('woff2');
            unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
        }

        @font-face {
            font-family: 'Roboto';
            font-style: normal;
            font-weight: 900;
            src: local('Roboto Black'), local('Roboto-Black'), url(https://fonts.gstatic.com/s/roboto/v15/mnpfi9pxYH-Go5UiibESIltXRa8TVwTICgirnJhmVJw.woff2) format('woff2');
            unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
        }

        @font-face {
            font-family: 'Roboto';
            font-style: italic;
            font-weight: 300;
            src: local('Roboto Light Italic'), local('Roboto-LightItalic'), url(https://fonts.gstatic.com/s/roboto/v15/7m8l7TlFO-S3VkhHuR0at44P5ICox8Kq3LLUNMylGO4.woff2) format('woff2');
            unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
        }

        @font-face {
            font-family: 'Roboto';
            font-style: italic;
            font-weight: 400;
            src: local('Roboto Italic'), local('Roboto-Italic'), url(https://fonts.gstatic.com/s/roboto/v15/vPcynSL0qHq_6dX7lKVByfesZW2xOQ-xsNqO47m55DA.woff2) format('woff2');
            unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
        }

        @font-face {
            font-family: 'Roboto';
            font-style: italic;
            font-weight: 700;
            src: local('Roboto Bold Italic'), local('Roboto-BoldItalic'), url(https://fonts.gstatic.com/s/roboto/v15/t6Nd4cfPRhZP44Q5QAjcC44P5ICox8Kq3LLUNMylGO4.woff2) format('woff2');
            unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
        }

        @font-face {
            font-family: 'Roboto';
            font-style: italic;
            font-weight: 900;
            src: local('Roboto Black Italic'), local('Roboto-BlackItalic'), url(https://fonts.gstatic.com/s/roboto/v15/bmC0pGMXrhphrZJmniIZpY4P5ICox8Kq3LLUNMylGO4.woff2) format('woff2');
            unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
        }
    </style>
    
    <link href="/favicon.ico" rel="shortcut icon" type="image/x-icon" />
    
    <link rel="stylesheet" href="https://scott.cranton.com/assets/css/main.css">

    <link rel="canonical" href="https://scott.cranton.com/tag/Kubernetes/">

    <link rel="alternate" type="application/rss+xml" title="Scott Cranton" href="https://scott.cranton.com/feed.xml">
</head>

    <body>
        <div class="wrapper">
            <aside class="user-profile fixed" role="complementary">
    <div class="burger">
        <input class="trigger hidden" id="toggleBurger" type="checkbox" />
        <label for="toggleBurger">
            <span>Navigation</span>
        </label>
    </div>

    <div class="compact-header">
        <a class="avatar" href="https://scott.cranton.com"><img alt="Avatar" src="/scottcranton.png" /></a>
        <div class="my-info">
            <strong class="my-name">Scott Cranton</strong>
            <span class="my-job-title">Solo.io Customer Success</span>
        </div>
    </div>

    
        
        <div class="mainmenu">
            <a href="https://scott.cranton.com" >Home</a>
            
                
            
                
            
                
            
                
                    <a href="https://scott.cranton.com/archive/" >Archive</a>
                
            
                
                    <a href="https://scott.cranton.com/publications/" >Publications</a>
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
        </div>
        
    

    <p class="about-me">I lead Customer Success at Solo.io. I enjoy hacking tech, and writing about it.</p>

    <ul class="socials">
        <li><a href="http://twitter.com/scottcranton"><svg title="twitter" width="16" height="16" ><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://scott.cranton.com/assets/svg/social-icons.svg#twitter-icon"></use></svg></a></li><li><a href="https://www.linkedin.com/in/scottcranton/"><svg title="linkedin" width="16" height="16" ><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://scott.cranton.com/assets/svg/social-icons.svg#linkedin-icon"></use></svg></a></li><li><a href="https://github.com/scranton"><svg title="github" width="16" height="16" ><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://scott.cranton.com/assets/svg/social-icons.svg#github-icon"></use></svg></a></li>

        

        
         <li><a href="https://scott.cranton.com/feed.xml"><svg title="" width="16" height="16"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://scott.cranton.com/assets/svg/social-icons.svg#rss-icon"></use></svg></a></li>
        
    </ul>
</aside>

            <main class="the-content" role="main">
                <div class="search" role="search">
    <div>
        <div class="show-results-count">0 Results</div>
        <div class="search-holder">
            <input type="text" id="search-input" placeholder="search for..." />
        </div>
    </div>
    <ul id="results-container" class="results-container"></ul>
</div>


                <h1>Posts Tagged - Kubernetes</h1>


    
        
    
        
    
        
        <article class="post" role="article" itemscope itemtype="http://schema.org/BlogPosting">
            <header class="post-header">
                <ul>
                    <li><time datetime="2019-05-06T13:51:24-04:00" itemprop="datePublished">6 May, 2019</time></li>
                    
                </ul>
                <h2 itemprop="name headline"><a href="https://scott.cranton.com/flagger_and_supergloo.html">SuperGloo to the Rescue! Making it easier to write applications for Service Meshes.</a></h2>
            </header>

            <div class="post-content">
                <p><img src="/assets/supergloo.png" alt="SuperGloo" title="SuperGloo" style="width:50%;" /></p>

<!--
<figure class="aligncenter">
    <img src="https://images.unsplash.com/photo-1531907700752-62799b2a3e84?ixlib=rb-1.2.1&auto=format&fit=crop&w=1350&q=80"/>
    <figcaption>Photo by <a href="https://unsplash.com/@tkristin" target="_blank">TK Hammonds</a>.</figcaption>
</figure>
-->

<h1 id="overview">Overview</h1>

<p>SuperGloo is a new open source project that helps with managing service meshes at scale. SuperGloo provides
an opinionated abstraction layer that simplifies the installation, management, and operations of one or more service
meshes like <a href="https://istio.io/">Istio</a>, <a href="https://aws.amazon.com/app-mesh/">AWS App Mesh</a>, <a href="https://linkerd.io/">Linkerd</a>
and <a href="https://www.consul.io/">HashiCorp Consul</a>. Supports on-site, in the cloud or any combination you need.</p>

<p><img src="/assets/supergloo_architecture.png" alt="SuperGloo Architecture" title="SuperGloo Architecture" style="padding-top: 50px; padding-bottom: 50px;" /></p>

<p>There are a growing number of articles on why SuperGloo, like <a href="https://blog.christianposta.com/">Christian Posta’s</a>
<a href="https://medium.com/solo-io/solo-io-streamlines-service-mesh-and-serverless-adoption-for-enterprises-in-google-cloud-c93b8aa04d81">“Solo.io Streamlines Service Mesh and Serverless Adoption for Enterprises in Google Cloud”</a>.
This article is going to focus on how SuperGloo can help software packages like <a href="https://github.com/weaveworks/flagger">Weaveworks Flagger</a>
work on multiple Services Meshes like Istio and AWS App Mesh that both support traffic shifting.</p>

<p>Flagger is a cool open source project that automates the promotion of Canary deployments of your Kubernetes services.
You associate a Flagger Canary Kubernetes custom resource (CRD) with your deployment and Flagger follows your defined
rules for helping roll out a new version. It detects when a new version of your service has deployed, instantiating your
new version in parallel to your existing version, slowly shifting request traffic between the two versions, and using
your defined Prometheus metric health checks to determine if Flagger should continue moving more traffic to the new
version or roll back to the old version. Since a Canary CRD is a YAML file, this provides you a
declarative way to ensure that all of your service upgrades follow your prescribed sophisticated rollout strategy and
complements GitOps pipelines used in <a href="https://github.com/weaveworks/flux">Weave Flux</a> and <a href="https://jenkins-x.io/">JenkinsX</a>.</p>

<p>More information on what Canary deployments and Traffic Shifting are is in the following posts. <a href="https://gloo.solo.io">Gloo</a>
uses the same underlying data plane technology - <a href="https://www.envoyproxy.io/">Envoy</a> - as Istio to provide traffic shifting capabilities used by
Flagger and Knative. Gloo is an API/Function gateway and not a full Service Mesh, so Gloo can be used in use cases that
do not require all of the power, and weight, of full service mesh implementations.</p>

<ul>
  <li><a href="/canary-deployments-with-weighted-routes.html">Canary Deployments with Gloo Function Gateway using Weighted Destinations</a></li>
  <li><a href="/knative-and-gloo.html">Automating your Services with Knative and Solo.io Gloo</a></li>
  <li><a href="https://jenkins-x.io/developing/knative/">Jenkins X Serverless Apps</a></li>
</ul>

<p>This article quickly runs through setting up the Flagger <code class="highlighter-rouge">podinfo</code> example application on SuperGloo with Istio so
you all can see what’s involved and try yourselves if you like.</p>

<h2 id="install-kubernetes-and-helm">Install Kubernetes and Helm</h2>

<p>The first step on our journey is to get a basic local Kubernetes cluster running. My friend <a href="https://twitter.com/christianh814">Christian Hernandez</a>
clued me in on <a href="https://kind.sigs.k8s.io/">kind (Kubernetes IN Docker)</a> from the Kubernetes sig-testing team. It’s a fast,
lightweight way to spin up/down a local cluster assuming you have a locally running copy of Docker, e.g., Docker Desktop.
This example works equally well in <code class="highlighter-rouge">minikube</code> if you prefer. The following code does the basics you need for most
Kubernetes clusters.</p>

<ul>
  <li>Creates a <code class="highlighter-rouge">kind</code> cluster with one control plane node and one worker node</li>
  <li>Configures the <code class="highlighter-rouge">KUBECONFIG</code> as <code class="highlighter-rouge">kind</code> creates a separate kubeconfig file for each <code class="highlighter-rouge">kind</code> cluster</li>
  <li>Installs Helm and Tiller with a service account for Tiller</li>
</ul>

<noscript><pre>400: Invalid request
</pre></noscript>
<script src="https://gist.github.com/798ced2125eedb4a93c2df65526a9359.js?file=create_cluster.sh"> </script>

<h2 id="install-supergloo-and-supergloo-installs-and-configures-istio">Install SuperGloo and SuperGloo installs and configures Istio</h2>

<p>Here’s where the magic happens so let’s spend a little time teasing out all the things that are happening due to these
few lines of code.</p>

<noscript><pre>400: Invalid request
</pre></noscript>
<script src="https://gist.github.com/798ced2125eedb4a93c2df65526a9359.js?file=install_supergloo.sh"> </script>

<p>The first command <code class="highlighter-rouge">supergloo init</code> installs SuperGloo into your Kubernetes cluster that is equivalent to using Helm
to install SuperGloo.</p>

<noscript><pre>400: Invalid request
</pre></noscript>
<script src="https://gist.github.com/798ced2125eedb4a93c2df65526a9359.js?file=install_supergloo_helm.sh"> </script>

<p>The second command <code class="highlighter-rouge">kubectl --namespace supergloo-system rollout status deployment/supergloo --watch=true</code> is a hack
to wait till the SuperGloo deployment is fully deployed and running. It’s similar to using the <code class="highlighter-rouge">--wait</code> option on a
Helm install.</p>

<p>The <code class="highlighter-rouge">supergloo install istio ...</code> command declares a custom resource and the SuperGloo controller installs and
configures Istio as declared. In this case, we are installing Istio version 1.0.6 with Istio’s Prometheus installation and
with Istio deploying sidecars in all pods within namespaces with the label <code class="highlighter-rouge">istio-injection=enabled</code>, i.e., <a href="kubectl --namespace supergloo-system rollout status deployment/supergloo --watch=true">Istio’s
default behavior for auto-injecting sidecars</a>. This imperative <code class="highlighter-rouge">supergloo install istio</code> command creates the following manifest that you could <code class="highlighter-rouge">kubectl apply</code>
if you prefer. Refer to the full <a href="https://supergloo.solo.io/v1/github.com/solo-io/supergloo/api/v1/install.proto.sk#istioinstall"><code class="highlighter-rouge">Install</code></a>
specification for more details.</p>

<noscript><pre>400: Invalid request
</pre></noscript>
<script src="https://gist.github.com/798ced2125eedb4a93c2df65526a9359.js?file=supergloo-install.yaml"> </script>

<h2 id="install-flagger">Install Flagger</h2>

<p>The following install Flagger and its dependent parts. The following is a quick summary of installing Flagger. More
details at <a href="https://docs.flagger.app/">Flagger Doc Site</a>.</p>

<ol>
  <li>Add a reference to Flagger helm repo</li>
  <li>Wait for Tiller to be fully running. Only an issue for quick scripts that create Kubernetes clusters from scratch</li>
  <li>Create a cluster role binding that allows Flagger to modify SuperGloo/Istio resources</li>
  <li>Install core Flagger referencing Istio’s provided Prometheus and telling Flagger that SuperGloo is the mesh controller</li>
  <li>Install Flagger’s Grafana dashboards which are not used as part of this demo</li>
  <li>Install Flagger’s LoadTester which can help generate test traffic during a Canary deployment if there is not enough
user traffic</li>
</ol>

<noscript><pre>400: Invalid request
</pre></noscript>
<script src="https://gist.github.com/798ced2125eedb4a93c2df65526a9359.js?file=install_flagger.sh"> </script>

<h2 id="install-flagger-example-application">Install Flagger example application</h2>

<p>The example application <a href="https://github.com/stefanprodan/k8s-podinfo"><code class="highlighter-rouge">podinfo</code></a> is a simple golang web application.
It is instrumented with Prometheus so we can tell if it’s performing well (or not) that helps with our Canary
deployment to validate that the new version is handling incoming traffic. The example application also has hooks
to allow you to generate faults if you want to explicitly fail a deployment to see how the Flagger Canary handles that
situation. Full details on the options around the Flagger example application are <a href="https://docs.flagger.app/usage/progressive-delivery">here</a>.
The following is the summary of installation steps.</p>

<ol>
  <li>Install a <code class="highlighter-rouge">test</code> namespace, the example Kubernetes Deployment manifest and an (optional) horizontal pod autoscaler</li>
  <li>Deploy the Canary policy for the example application. More details on that in a moment</li>
  <li>Wait for the Canary controller to report that it’s fully ready, which means Istio and Flagger are fully deployed and
running</li>
</ol>

<noscript><pre>400: Invalid request
</pre></noscript>
<script src="https://gist.github.com/798ced2125eedb4a93c2df65526a9359.js?file=install_example.sh"> </script>

<p>The Canary manifest has a target reference that associates it with the podinfo deployment. The Canary analysis says that
for every <code class="highlighter-rouge">interval</code> (1 minute) Flagger increment by <code class="highlighter-rouge">stepWeight</code> (10%) more request traffic to the new version up to
<code class="highlighter-rouge">maxWeight</code> (50%) as long as the <code class="highlighter-rouge">metrics</code> stay within the defined healthy ranges. If more than <code class="highlighter-rouge">threshold</code> (5) health
checks fail, then rollback to 100% of traffic to the old version and delete the new version deployment. There is also
an optional section to allow the Flagger loadtester to generate additional traffic to help validate the new Canary
version, i.e., hard to know if the new version works if it has not handled any requests.</p>

<noscript><pre>400: Invalid request
</pre></noscript>
<script src="https://gist.github.com/798ced2125eedb4a93c2df65526a9359.js?file=podinfo-canary.yaml"> </script>

<h2 id="deploy-a-new-image-version-and-watch-the-canary-deployment">Deploy a new image version and watch the Canary deployment</h2>

<p>First, we check on the currently deployed image version and print that out to help us verify if the test updates
the service like we expect; should be <code class="highlighter-rouge">quay.io/stefanprodan/podinfo:1.4.0</code>. Then to help make the changes more visible,
we trigger a background process to update the image version to <code class="highlighter-rouge">quay.io/stefanprodan/podinfo:1.4.1</code> after a five second
delay. We then loop and print out the change events for podinfo to see the traffic weight changes until the Canary
reports Success. You’d need to change this loop if you want to try introducing errors to see the Canary rollback. Lastly,
we’ll print out the image version which should be <code class="highlighter-rouge">quay.io/stefanprodan/podinfo:1.4.1</code> is everything succeeded.</p>

<noscript><pre>400: Invalid request
</pre></noscript>
<script src="https://gist.github.com/798ced2125eedb4a93c2df65526a9359.js?file=update_version.sh"> </script>

<h2 id="cleanup-kubernetes">Cleanup Kubernetes</h2>

<p>The final step is to clean up the Kubernetes cluster, which in our case means to delete the kind cluster by running
<code class="highlighter-rouge">kind delete cluster</code> and unsetting the <code class="highlighter-rouge">KUBECONFIG</code> environment variable.</p>

<h2 id="everything">Everything</h2>

<p>Here’s an <a href="https://asciinema.org/">Asciinema</a> screen recording of the whole example script running, and afterward you
can see the whole script if you wanted to try yourself. The Asciinema recorder speeds up any long running commands,
that is, if a command takes more than two seconds to execute the playback delays up to two seconds. This speedup reduces
the run time from 15+ minutes to around two minutes.</p>

<script id="asciicast-hUwE6wzhmEkw2KIK74dtNiIfd" src="https://asciinema.org/a/hUwE6wzhmEkw2KIK74dtNiIfd.js" data-rows="32" data-cols="120" async=""></script>

<noscript><pre>400: Invalid request
</pre></noscript>
<script src="https://gist.github.com/798ced2125eedb4a93c2df65526a9359.js?file=run_flagger_demo.sh"> </script>

<h1 id="summary">Summary</h1>

<p>Hopefully, this example gave you a taste of how SuperGloo supports a Canary deployment engine like Flagger. Before
SuperGloo you’d either need to learn how to install all of Istio yourself or be constrained to using a managed Istio or
App Mesh installation from GKE or AWS respectively. Those are good managed offerings, but they do limit your choices
to the versions and configurations they currently support.</p>

<p>SuperGloo provides a great abstraction and management layer to help applications leverage one or more Service Meshes
without needing to get deep into the weeds of the huge API surface area of any one of the meshes like Istio or
App Mesh. SuperGloo makes it easy for applications to use just what they need of the underlying meshes. That helps
with adoption on Service Meshes based on the feedback I’ve heard, that is, many are currently experimenting with
Istio or App Mesh or Linkerd for just on capability, typically traffic shifting or mutual TLS, and they’re finding it
difficult to manage and configure the whole mesh even though they aren’t using those other capabilities. SuperGloo to
the rescue to help make it easier to use just the parts of Service Meshes that add value today, and allow you to add
more as you need it including mixing and matching multiple service meshes easily to get the biggest return on your
investment.</p>

<p>I strongly encourage you to learn more yourself as its fun to learn new technology, especially tech that helps you solve
complex challenges and accelerates your ability to deploy larger and more sophisticated systems.</p>

<ul>
  <li><a href="httsp://supergloo.solo.io">SuperGloo</a></li>
  <li><a href="https://docs.flagger.app/">Flagger</a></li>
  <li><a href="https://istio.io">Istio</a></li>
</ul>


                
                    <p><a href="/flagger_and_supergloo.html" role="button">Read More</a></p>
                
            </div>

            <footer class="post-footer">
                <div class="share">Share
                    <ul class="social-networks">
                        <li class="share-facebook"><a href="https://www.facebook.com/sharer.php?s=100&p[title]=SuperGloo to the Rescue! Making it easier to write applications for Service Meshes.&p[summary]=How SuperGloo abstracts Service Meshes to allow applications to run on one or more Service Meshes like a superhero.&p[url]=https://scott.cranton.com/flagger_and_supergloo.html" class="s_facebook" target="_blank" onclick="window.open(this.href, '','width=700,height=300');return false;"><svg title="" width="16" height="16"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://scott.cranton.com/assets/svg/social-icons.svg#facebook-icon"></use></svg></a></a></li>
                        <li class="share-twitter"><a href="http://twitter.com/share?url=https://scott.cranton.com/flagger_and_supergloo.html&text=How SuperGloo abstracts Service Meshes to allow applications to run on one or more Service Meshes like a superhero.&hashtags=SuperGloo,Service Mesh,Kubernetes," rel="noreferrer" target="_blank" onclick="window.open(this.href, '','width=700,height=300');return false;"><svg title="" width="16" height="16"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://scott.cranton.com/assets/svg/social-icons.svg#twitter-icon"></use></svg></a></li>
                    </ul>
                </div>
                
                <div class="tags">
                    <ul>
                        
                        <li><a href="https://scott.cranton.com/tag/SuperGloo">SuperGloo</a></li>
                        
                        <li><a href="https://scott.cranton.com/tag/Service Mesh">Service Mesh</a></li>
                        
                        <li><a href="https://scott.cranton.com/tag/Kubernetes">Kubernetes</a></li>
                        
                    </ul>
                </div>
                
            </footer>
        </article>
        
    

    
        
    
        
    
        
        <article class="post" role="article" itemscope itemtype="http://schema.org/BlogPosting">
            <header class="post-header">
                <ul>
                    <li><time datetime="2019-04-07T09:29:21-04:00" itemprop="datePublished">7 Apr, 2019</time></li>
                    
                </ul>
                <h2 itemprop="name headline"><a href="https://scott.cranton.com/ingress_and_beyond.html">Kubernetes Ingress Past, Present, and Future</a></h2>
            </header>

            <div class="post-content">
                <figure class="aligncenter">
    <img src="/assets/reflect.jpeg" />
    <figcaption>Photo by <a href="https://unsplash.com/@lukeporter" target="_blank">Luke Porter</a>.</figcaption>
</figure>

<h1 id="overview">Overview</h1>

<p>This post was inspired by listening to the February 19, 2019, <a href="https://kubernetespodcast.com/">Kubernetes Podcast</a>,
<a href="https://kubernetespodcast.com/episode/041-ingress/">“Ingress, with Tim Hockin.”</a> The Kubernetes Podcast is turning out
to be a very well done podcast overall, and well worth the listen. In the Ingress episode, the podcasters interview
Tim Hockin who’s one of the original Kubernetes co-founders, a team lead on the Kubernetes predecessor Borg/Omega,
and is still very active within the Kubernetes community such as chairing the <a href="https://github.com/kubernetes/community/tree/master/sig-network">Kubernetes Network Special Interest Group</a>
that currently own the Ingress resource specification. Tim talks in the podcast about the history of the
<a href="https://kubernetes.io/docs/concepts/services-networking/ingress/">Kubernetes Ingress</a>, current developments around
Ingress, and proposed futures. This talk inspired me to reflect on both Ingress Controllers (realizes the implementation of
Ingress manifest) and Ingress the concept (allow client outside the Kubernetes cluster to access services running in
the Kubernetes cluster).</p>

<h2 id="so-whats-a-kubernetes-ingress">So what’s a Kubernetes Ingress?</h2>

<p>To paraphrase from the <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/#what-is-ingress">Kubernetes Ingress</a>
documentation, Ingress is an L7 network service that exposes HTTP(S) routes from outside to inside a Kubernetes cluster.
A Kubernetes cluster may have one or more <a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/">Ingress Controllers</a>
running, and each controller manages service reachability, load balancing, TLS/SSL termination, and other services for
that controller’s associated routes.</p>

<p><img src="/assets/gloo_as_ingress.png" alt="Gloo as Ingress" /></p>

<p>Each Ingress manifest includes an annotation that indicates which Ingress controller should manage that Ingress resource.
For example, to have <a href="https://solo.io">Solo.io</a> <a href="https://gloo.solo.io">Gloo</a> manage a specific Ingress resource, you
would specify the following. Note the included annotation <code class="highlighter-rouge">kubernetes.io/ingress.class: gloo</code>.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">extensions/v1beta1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Ingress</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">annotations</span><span class="pi">:</span>
    <span class="s">kubernetes.io/ingress.class</span><span class="pi">:</span> <span class="s">gloo</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">chart</span><span class="pi">:</span> <span class="s">jsonplaceholder-v0.1.0</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">jsonplaceholder-jsonplaceholder</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">default</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">rules</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">host</span><span class="pi">:</span> <span class="s">gloo.example.com</span>
    <span class="na">http</span><span class="pi">:</span>
      <span class="na">paths</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">path</span><span class="pi">:</span> <span class="s">/.*</span>
        <span class="na">backend</span><span class="pi">:</span>
          <span class="na">serviceName</span><span class="pi">:</span> <span class="s">jsonplaceholder-jsonplaceholder</span>
          <span class="na">servicePort</span><span class="pi">:</span> <span class="s">8080</span>
</code></pre></div></div>

<h2 id="ingress-challenges">Ingress Challenges</h2>

<p>Ingress has existed as a beta extension since Kubernetes 1.1, and it’s proven to be a lowest common denominator API. For
example, the NGNIX community Ingress Controller is used by many in production, but that NGNIX Ingress controller
requires the use of many <a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/">NGNIX specific Ingress Annotations</a>
for all but the simplest use cases. The current Kubernetes Ingress resource specification has many limitations like that all
referenced services and secrets MUST be in the same namespace as the Ingress, i.e., no cross namespace referencing.
And there have been long debates about how exactly to interpret the <code class="highlighter-rouge">path</code> attribute; is it a regular expression like
the documentation implies OR is it a path prefix like some controllers like NGNIX implement. These challenges have made
it, in practice, difficult to have an Ingress manifest that is portable across implementations. The current Ingress
manifest has also proven difficult to round trip sync with <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/">Custom Resources (CRD)</a>
which is unfortunate as CRDs are proving to be a beneficial way to extend Kubernetes.</p>

<h2 id="whats-next-for-ingress">What’s Next for Ingress?</h2>

<p>In the podcast, Tim Hockin says given how many are using the current beta Ingress spec in production, there is a push
to move the existing Ingress spec to GA status, and then start work on a next-generation specification, either an Ingress v2 or
breaking up Ingress across multiple CRDs. Tim mentions how the Kubernetes community is looking at several
<a href="https://www.envoyproxy.io/">Envoy</a> based Ingress implementations for inspiration for the next generation of Ingress. For
example, <a href="https://github.com/heptio/contour">Heptio Contour</a> has created a very interesting, and implementation
neutral CRD called <a href="https://github.com/heptio/contour/blob/master/docs/ingressroute.md">Ingress Route</a>. An Ingress Route
looks to address the governance challenges with Ingress, for example, if a company wants to expose a
<code class="highlighter-rouge">/eng</code> route path there are many challenges with the current Ingress model as you can have conflicting Ingress
manifests for the route <code class="highlighter-rouge">/eng</code>. Ingress Route provides a way to create governance and delegation such as cluster admins
can define a virtual host <code class="highlighter-rouge">/eng</code> and delegate implementation explicitly to the <code class="highlighter-rouge">eng</code> namespace, and this prevents others
from overriding that route path.</p>

<p>The <a href="https://istio.io/">Istio</a> community, also based on Envoy like Heptio Contour, are also defining Ingress CRDs.</p>

<p>It will be fascinating to see how Ingress evolves in the not too distant future.</p>

<p>Related reading: <a href="https://medium.com/solo-io/api-gateways-are-going-through-an-identity-crisis-d1d833a313d7">API Gateways are going through an identity crisis</a>.</p>

<h2 id="demo-time">Demo Time</h2>

<p>I find it helpful to see working code to help make concepts more real, so let’s run through a few examples of Ingress and
beyond.</p>

<p>For this example, I’m going to use a Kubernetes service created from <a href="https://jsonplaceholder.typicode.com/">https://jsonplaceholder.typicode.com/</a>, which
provides a quick set of REST APIs that provide different JSON output that can be helpful for testing. It’s based on
a Node.js <a href="https://github.com/typicode/json-server">json-server</a> - it’s very cool and worth looking at independently. I
forked the original GitHub <a href="https://github.com/typicode/jsonplaceholder">jsonplaceholder repository</a>, ran <a href="https://draft.sh/"><code class="highlighter-rouge">draft create</code></a>
on the project, and made a couple of tweaks to the generated <a href="https://helm.sh/">Helm</a> chart. <a href="https://draft.sh/">Draft</a>
is a super fast and easy way to bootstrap existing code into Kubernetes. I’m running all of this example locally using
<a href="https://kubernetes.io/docs/setup/minikube/">minikube</a>.</p>

<p>The jsonplaceholder service comes with six common resources each of which returns several JSON objects. For this
example, we’ll be getting the first user resource at <code class="highlighter-rouge">/users/1</code>.</p>

<ul>
  <li><code class="highlighter-rouge">/posts</code>	100 posts</li>
  <li><code class="highlighter-rouge">/comments</code>	500 comments</li>
  <li><code class="highlighter-rouge">/albums</code>	100 albums</li>
  <li><code class="highlighter-rouge">/photos</code>	5000 photos</li>
  <li><code class="highlighter-rouge">/todos</code>	200 todos</li>
  <li><code class="highlighter-rouge">/users</code>	10 users</li>
</ul>

<p>Following is a script to try this example yourself, and there’s also an <a href="https://asciinema.org/">asciinema</a> playback so you can see
what it looks like running on my machine. We’ll unpack what’s happening following the playback.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Install tooling</span>
brew update
brew cask <span class="nb">install </span>minikube
brew <span class="nb">install </span>kubernetes-cli <span class="se">\</span>
  kubernetes-helm <span class="se">\</span>
  azure/draft/draft <span class="se">\</span>
  glooctl

<span class="c"># Create and set up local Kubernetes Cluster</span>
minikube start
helm init
draft init
glooctl <span class="nb">install </span>ingress

<span class="c"># Draft runs better locally if you configure</span>
<span class="c"># against minikube docker daemon</span>
<span class="nb">eval</span> <span class="k">$(</span>minikube docker-env<span class="k">)</span>

<span class="c"># Get and run the example</span>
git clone https://github.com/scranton/jsonplaceholder.git
<span class="nb">cd </span>jsonplaceholder
draft up

<span class="c"># Validate all is running</span>
kubectl get all <span class="nt">--namespace</span> default
kubectl get all <span class="nt">--namespace</span> gloo-system
kubectl get ingress <span class="nt">--namespace</span> default
curl <span class="nt">--header</span> <span class="s2">"Host: gloo.example.com"</span> <span class="se">\</span>
  <span class="k">$(</span>glooctl proxy url <span class="nt">--name</span> ingress-proxy<span class="k">)</span>/users/1
</code></pre></div></div>

<script id="asciicast-JjLna1ONZiGmQeYrJhP4oNcS5" src="https://asciinema.org/a/JjLna1ONZiGmQeYrJhP4oNcS5.js" data-speed="1.5" data-rows="32" data-cols="80" async=""></script>

<h2 id="what-happened">What Happened?</h2>

<p>We installed local tooling (you can check respective websites for full install details)</p>

<ul>
  <li><a href="https://kubernetes.io/docs/setup/minikube/">minikube</a></li>
  <li><a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/">kubectl</a></li>
  <li><a href="https://helm.sh/">Helm</a></li>
  <li><a href="https://draft.sh/">Draft</a></li>
  <li><a href="https://gloo.solo.io">glooctl</a></li>
</ul>

<p>We then started up a local Kubernetes cluster (minikube) and initialized Helm and Draft. We also installed
<a href="https://gloo.solo.io/user_guides/basic_ingress/">Gloo ingress</a> into our local cluster.</p>

<p>We then <code class="highlighter-rouge">git clone</code> our example and used <code class="highlighter-rouge">draft up</code> to build and deploy it to our cluster. Let’s spend a minute on
what happened in this step. I originally forked the <code class="highlighter-rouge">jsonplaceholder</code> GitHub repository and ran <code class="highlighter-rouge">draft create</code> against
its code. Draft autodetects the source code language, in this case, Node.js, and creates both a <code class="highlighter-rouge">Dockerfile</code> that builds
our example application into an image container and creates a default Helm chart. I then made a few minor tweaks to the
Helm chart to enable its Ingress. Let’s look at that Ingress manifest. The main changes are the addition of the
<code class="highlighter-rouge">ingress.class: gloo</code> annotation to mark this Ingress for Gloo’s Ingress Controller. And the host is set to
<code class="highlighter-rouge">gloo.example.com</code>, which is why our curl statement set <code class="highlighter-rouge">curl --header "Host: gloo.example.com"</code>.</p>

<figure>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="pi"></span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">extensions/v1beta1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Ingress</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="pi"></span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">chart</span><span class="pi">:</span> <span class="s2">"</span><span class="s">-"</span>
  <span class="na">annotations</span><span class="pi">:</span>
    <span class="s">kubernetes.io/ingress.class</span><span class="pi">:</span> <span class="pi"></span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">rules</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">host</span><span class="pi">:</span> <span class="pi"></span>
    <span class="na">http</span><span class="pi">:</span>
      <span class="na">paths</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">path</span><span class="pi">:</span> <span class="s">/.*</span>
        <span class="na">backend</span><span class="pi">:</span>
          <span class="na">serviceName</span><span class="pi">:</span> <span class="pi"></span>
          <span class="na">servicePort</span><span class="pi">:</span> <span class="pi"></span>
<span class="pi"></span></code></pre></figure>

  <figcaption>charts/template/ingress.yaml</figcaption>
</figure>

<p>For more examples of using Gloo as an basic Ingress controller you can check out
<a href="https://scott.cranton.com/kubernetes-ingress-controlling-with-gloo.html">Kubernetes Ingress Control using Gloo</a>.</p>

<p>You may have also noticed the call to <code class="highlighter-rouge">$(glooctl proxy url --name ingress-proxy)</code> in the curl command. This is needed
when you’re running in a local environment like minikube and you need to get the host IP and port of the Gloo proxy
server. When Gloo is deployed to a Cloud Provider like Google or AWS, then those environments would associate a static IP and
allow port 80 (or port 443 for HTTPS) to be used, and that static IP would be registered with a DNS server, i.e., 
when Gloo is deployed to a cloud-managed Kubernetes you could do <code class="highlighter-rouge">curl http://gloo.example.com/users/1</code>.</p>

<h2 id="ingress-example-challenges">Ingress Example Challenges</h2>

<p>Let’s say we wanted to remap the exiting <code class="highlighter-rouge">/users/1</code> to <code class="highlighter-rouge">/people/1</code> as users are people too. That becomes tricky with
Ingress manifests as we can set up a second rule for <code class="highlighter-rouge">/people</code>, but we need to rewrite that path to <code class="highlighter-rouge">/users</code> before
sending to our service as it doesn’t know how to handle requests for <code class="highlighter-rouge">/people</code>. If you were using the NGNIX ingress, you
could add another annotation <code class="highlighter-rouge">nginx.ingress.kubernetes.io/rewrite-target: /</code>, but now we’re adding implementation
specific annotations, that is, the nginx annotation won’t be recognized by other Ingress Controllers. And annotations
are a flat name space so adding lots of annotations can get quite messy, which is part of why
<a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/">Custom Resources (CRD)</a> was
created. Let’s see what the original route, and our path re-writing route, would look like in a CRD based Ingress: Gloo.</p>

<h2 id="gloo-virtual-services">Gloo Virtual Services</h2>

<p>Gloo uses a concept called <a href="https://gloo.solo.io/introduction/concepts#virtual-services">Virtual Service</a> that is
derived from similar ideas in Istio and Envoy and is conceptually equivalent to an Ingress resource. Easiest to show
you the equivalent of the example Ingress we’ve created so far in a Gloo Virtual Service.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">gateway.solo.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">VirtualService</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">default</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">gloo-system</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">virtualHost</span><span class="pi">:</span>
    <span class="na">domains</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">gloo.example.com</span>
    <span class="na">routes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">matcher</span><span class="pi">:</span>
        <span class="na">prefix</span><span class="pi">:</span> <span class="s">/</span>
      <span class="na">routeAction</span><span class="pi">:</span>
        <span class="na">single</span><span class="pi">:</span>
          <span class="na">upstream</span><span class="pi">:</span>
            <span class="na">name</span><span class="pi">:</span> <span class="s">default-jsonplaceholder-jsonplaceholder-8080</span>
            <span class="na">namespace</span><span class="pi">:</span> <span class="s">gloo-system</span>
</code></pre></div></div>

<p>You’ll notice that it looks very similar to the Ingress we had previously created with a few subtle changes. The path
specifier is <code class="highlighter-rouge">prefix: /</code> which is generally what people intend, i.e., if the beginning of the request message path
matches the route path specifier than apply the route actions. If we wanted to exactly match the previous Ingress, we could use
<code class="highlighter-rouge">regex: /.*</code> instead. Virtual Services allow you to specify paths by: prefix, exact, and regular expression. You can
also see that instead of <code class="highlighter-rouge">backend:</code> with <code class="highlighter-rouge">serviceName</code> and <code class="highlighter-rouge">servicePort</code>, a Virtual Service has a <code class="highlighter-rouge">routeAction</code> that
delegates to a <code class="highlighter-rouge">single</code> <code class="highlighter-rouge">upstream</code>. Gloo upstreams are auto-discovered and can refer to Kubernetes Services AND
REST/gRPC function, cloud functions like AWS Lambda and Google Functions, and other external to Kubernetes services.</p>

<p>More details on Gloo at:</p>

<ul>
  <li><a href="https://medium.com/solo-io/routing-with-gloo-function-gateway-301765bb103e">Routing with Gloo Function Gateway</a></li>
  <li><a href="https://medium.com/solo-io/5-minutes-with-gloo-the-anatomy-of-a-virtualservice-4deb4cfc558e">5 minutes with Gloo - The Anatomy of a VirtualService</a></li>
</ul>

<p>Let’s go back to our example, and update our Virtual Service to do the path rewrite we wanted, i.e., <code class="highlighter-rouge">/people</code> =&gt; <code class="highlighter-rouge">/users</code></p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">gateway.solo.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">VirtualService</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">default</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">gloo-system</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">virtualHost</span><span class="pi">:</span>
    <span class="na">domains</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">gloo.example.com</span>
    <span class="na">routes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">matcher</span><span class="pi">:</span>
        <span class="na">prefix</span><span class="pi">:</span> <span class="s">/people</span>
      <span class="na">routeAction</span><span class="pi">:</span>
        <span class="na">single</span><span class="pi">:</span>
          <span class="na">upstream</span><span class="pi">:</span>
            <span class="na">name</span><span class="pi">:</span> <span class="s">default-jsonplaceholder-jsonplaceholder-8080</span>
            <span class="na">namespace</span><span class="pi">:</span> <span class="s">gloo-system</span>
      <span class="na">routePlugins</span><span class="pi">:</span>
        <span class="na">prefixRewrite</span><span class="pi">:</span>
          <span class="na">prefixRewrite</span><span class="pi">:</span> <span class="s">/users</span>
    <span class="pi">-</span> <span class="na">matcher</span><span class="pi">:</span>
        <span class="na">prefix</span><span class="pi">:</span> <span class="s">/</span>
      <span class="na">routeAction</span><span class="pi">:</span>
        <span class="na">single</span><span class="pi">:</span>
          <span class="na">upstream</span><span class="pi">:</span>
            <span class="na">name</span><span class="pi">:</span> <span class="s">default-jsonplaceholder-jsonplaceholder-8080</span>
            <span class="na">namespace</span><span class="pi">:</span> <span class="s">gloo-system</span>
</code></pre></div></div>

<p>We’ve added a second route matcher, just like adding a second route path in an Ingress, and specified <code class="highlighter-rouge">prefix: /people</code>.
This will match all requests that start with <code class="highlighter-rouge">/people</code>, and all other calls to the <code class="highlighter-rouge">gloo.example.com</code> domain will be
handled by the other route matcher. We also added a <code class="highlighter-rouge">routePlugins</code> section that will rewrite the request path to <code class="highlighter-rouge">/users</code> such
that our service will now correctly handle our request. <a href="https://gloo.solo.io/user_guides/advanced_route_plugins/">Route Plugins</a>
allow you to perform many operations on both the request to the upstream service and the response back from the upstream
service. Best shown with an example, so for our new <code class="highlighter-rouge">/people</code> route let’s also transform the response to both add
a new header <code class="highlighter-rouge">x-test-phone</code> with a value from the response body, and let’s transform the response body to return a
couple of fields: name, and the address/street and address/city.</p>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">gateway.solo.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">VirtualService</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">creationTimestamp</span><span class="pi">:</span> <span class="s2">"</span><span class="s">2019-04-08T21:43:45Z"</span>
  <span class="na">generation</span><span class="pi">:</span> <span class="s">1</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">default</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">gloo-system</span>
  <span class="na">resourceVersion</span><span class="pi">:</span> <span class="s2">"</span><span class="s">772"</span>
  <span class="na">selfLink</span><span class="pi">:</span> <span class="s">/apis/gateway.solo.io/v1/namespaces/gloo-system/virtualservices/default</span>
  <span class="na">uid</span><span class="pi">:</span> <span class="s">6267ee31-5a47-11e9-bc30-867df7be8a8a</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">virtualHost</span><span class="pi">:</span>
    <span class="na">domains</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">gloo.example.com</span>
    <span class="na">routes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">matcher</span><span class="pi">:</span>
        <span class="na">prefix</span><span class="pi">:</span> <span class="s">/people</span>
      <span class="na">routeAction</span><span class="pi">:</span>
        <span class="na">single</span><span class="pi">:</span>
          <span class="na">upstream</span><span class="pi">:</span>
            <span class="na">name</span><span class="pi">:</span> <span class="s">default-jsonplaceholder-jsonplaceholder-8080</span>
            <span class="na">namespace</span><span class="pi">:</span> <span class="s">gloo-system</span>
      <span class="na">routePlugins</span><span class="pi">:</span>
        <span class="na">prefixRewrite</span><span class="pi">:</span>
          <span class="na">prefixRewrite</span><span class="pi">:</span> <span class="s">/users</span>
        <span class="na">transformations</span><span class="pi">:</span>
          <span class="na">responseTransformation</span><span class="pi">:</span>
            <span class="na">transformation_template</span><span class="pi">:</span>
              <span class="na">body</span><span class="pi">:</span>
                <span class="na">text</span><span class="pi">:</span> <span class="s1">'</span><span class="s">{</span><span class="nv"> </span><span class="s">"name":</span><span class="nv"> </span><span class="s">"",</span><span class="nv"> </span><span class="s">"address":</span>
                  <span class="s">{</span><span class="nv"> </span><span class="s">"street":</span><span class="nv"> </span><span class="s">"",</span>
                    <span class="s">"city":</span><span class="nv"> </span><span class="s">""</span><span class="nv"> </span><span class="s">}</span><span class="nv"> </span><span class="s">}'</span>
              <span class="na">headers</span><span class="pi">:</span>
                <span class="na">x-test-phone</span><span class="pi">:</span>
                  <span class="na">text</span><span class="pi">:</span> <span class="s1">'</span><span class="s">'</span>
    <span class="pi">-</span> <span class="na">matcher</span><span class="pi">:</span>
        <span class="na">prefix</span><span class="pi">:</span> <span class="s">/</span>
      <span class="na">routeAction</span><span class="pi">:</span>
        <span class="na">single</span><span class="pi">:</span>
          <span class="na">upstream</span><span class="pi">:</span>
            <span class="na">name</span><span class="pi">:</span> <span class="s">default-jsonplaceholder-jsonplaceholder-8080</span>
            <span class="na">namespace</span><span class="pi">:</span> <span class="s">gloo-system</span></code></pre></figure>

<p>Let’s see what that looks like. My example GitHub repository already included
the full Gloo Virtual Service we just examined. We need to configure Gloo for
<code class="highlighter-rouge">gateway</code> which means adding another proxy to handle Virtual Services in
addition to Ingress resources. We’ll use <code class="highlighter-rouge">draft up</code> to ensure our example is
fully deployed including the full Virtual Service, and then we’ll call both
<code class="highlighter-rouge">/users/1</code> and <code class="highlighter-rouge">/people/1</code> to see the differences.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Install Gloo and update example</span>
glooctl <span class="nb">install </span>gateway
draft up

<span class="c"># Call service</span>
curl <span class="nt">--verbose</span> <span class="nt">--header</span> <span class="s2">"Host: gloo.example.com"</span> <span class="se">\</span>
  <span class="k">$(</span>glooctl proxy url <span class="nt">--name</span> gateway-proxy<span class="k">)</span>/users/1

curl <span class="nt">--verbose</span> <span class="nt">--header</span> <span class="s2">"Host: gloo.example.com"</span> <span class="se">\</span>
  <span class="k">$(</span>glooctl proxy url <span class="nt">--name</span> gateway-proxy<span class="k">)</span>/people/1
</code></pre></div></div>

<script id="asciicast-5DXyvz6bOmd6zTjayKJ4kjZlB" src="https://asciinema.org/a/5DXyvz6bOmd6zTjayKJ4kjZlB.js" data-speed="1.5" data-rows="32" data-cols="80" async=""></script>

<p><img src="/assets/mind_blown.png" alt="Mind Blown" style="width: 75px;" class="aligncenter" /></p>

<p>Ok, well not that mind-blowing if you’ve used other L7 networking products or done other integration work, but still
pretty cool relative to standard Ingress objects. Gloo is using Inja Templates to process the JSON response body.
More details in the <a href="https://gloo.solo.io/user_guides/advanced_route_plugins#transformation_template">Gloo documentation</a>.</p>

<h1 id="summary">Summary</h1>

<p>In this article, we touched on some of the history and difficulties with the existing Kubernetes Ingress resources. Ingress
resources continue to play a role within Kubernetes deployments despite the many challenges that annotation-based
extensions have. Kubernetes Custom Resources (CRDs) was created to address some of those extension challenges and
can provide a cleaner way to extend Kubernetes as you saw in the Gloo Ingress and Gateway examples. I’m a big believer
in the potential of Envoy based solutions as are others in the Istio and Contour communities, and it will be exciting
to see how the Kubernetes community decides to evolve Ingress after they finally move the existing
resource spec to GA status.</p>


                
                    <p><a href="/ingress_and_beyond.html" role="button">Read More</a></p>
                
            </div>

            <footer class="post-footer">
                <div class="share">Share
                    <ul class="social-networks">
                        <li class="share-facebook"><a href="https://www.facebook.com/sharer.php?s=100&p[title]=Kubernetes Ingress Past, Present, and Future&p[summary]=Learn how Knative and Solo.io Gloo work together to support on demand code delivery in Kubernetes.&p[url]=https://scott.cranton.com/ingress_and_beyond.html" class="s_facebook" target="_blank" onclick="window.open(this.href, '','width=700,height=300');return false;"><svg title="" width="16" height="16"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://scott.cranton.com/assets/svg/social-icons.svg#facebook-icon"></use></svg></a></a></li>
                        <li class="share-twitter"><a href="http://twitter.com/share?url=https://scott.cranton.com/ingress_and_beyond.html&text=Learn how Knative and Solo.io Gloo work together to support on demand code delivery in Kubernetes.&hashtags=Gloo,Ingress,Kubernetes," rel="noreferrer" target="_blank" onclick="window.open(this.href, '','width=700,height=300');return false;"><svg title="" width="16" height="16"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://scott.cranton.com/assets/svg/social-icons.svg#twitter-icon"></use></svg></a></li>
                    </ul>
                </div>
                
                <div class="tags">
                    <ul>
                        
                        <li><a href="https://scott.cranton.com/tag/Gloo">Gloo</a></li>
                        
                        <li><a href="https://scott.cranton.com/tag/Ingress">Ingress</a></li>
                        
                        <li><a href="https://scott.cranton.com/tag/Kubernetes">Kubernetes</a></li>
                        
                    </ul>
                </div>
                
            </footer>
        </article>
        
    

    
        
    
        
    
        
        <article class="post" role="article" itemscope itemtype="http://schema.org/BlogPosting">
            <header class="post-header">
                <ul>
                    <li><time datetime="2019-04-02T15:28:31-04:00" itemprop="datePublished">2 Apr, 2019</time></li>
                    
                </ul>
                <h2 itemprop="name headline"><a href="https://scott.cranton.com/knative-and-gloo.html">Automating your Services with Knative and Solo.io Gloo</a></h2>
            </header>

            <div class="post-content">
                <p><a href="https://github.com/knative/">Knative</a> is talked about a great deal, especially around how its capabilities can
help provide more standard building blocks on top of Kubernetes for building microservices and serverless like services,
e.g., scale to zero, and scale on demand. Knative high level has three capability areas: building, serving, and eventing.
This post will provide some examples around Knative Build and Knative Serving with Solo.io Gloo.</p>

<p>Knative Serving initially included all of Istio only to use a small fraction of its capabilities around being a
Kubernetes cluster ingress. Recently the Knative team added <a href="https://solo.io">Solo.io</a> <a href="https://gloo.solo.io">Gloo</a> as
an alternative to Istio. More details are available in <a href="https://medium.com/solo-io/gloo-knative-and-the-future-of-serverless-902b89f15c2c">Gloo, Knative and the future of Serverless</a>
and <a href="https://medium.com/solo-io/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative-324753586f3a">Gloo, by Solo.io, is the first alternative to Istio on Knative</a>.</p>

<p>This post shows a quick example of Knative Building, Knative Serving, and Gloo integration.</p>

<p>All of the Kubernetes Manifests are located in the following GitHub repository
<a href="https://github.com/scranton/helloworld-knative">https://github.com/scranton/helloworld-knative</a>. I encourage you to fork that repository to help you try these examples
yourself.</p>

<h1 id="setup">Setup</h1>

<p>These instructions assume you are running on a clean, recent <a href="https://kubernetes.io/docs/setup/minikube/">minikube</a>
install locally, and that you also have <code class="highlighter-rouge">kubectl</code> available locally.</p>

<h2 id="install-gloo">Install Gloo</h2>

<p>On Mac or Linux, the quickest option is to use <a href="https://bash.sh/">Homebrew</a>. Full Gloo
install instructions at <a href="https://gloo.solo.io/installation/install_glooctl/">Gloo documentation</a>.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install </span>glooctl
</code></pre></div></div>

<p>Then assuming you’ve got a running <code class="highlighter-rouge">minikube</code>, and <code class="highlighter-rouge">kubectl</code> set up against that <code class="highlighter-rouge">minikube</code> instance, i.e., <code class="highlighter-rouge">kubectl
config current-context</code> returns <code class="highlighter-rouge">minikube</code>, run the following to install Gloo with Knative Serving.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>glooctl <span class="nb">install </span>knative
</code></pre></div></div>

<h1 id="deploy-existing-exampleimage">Deploy existing example image</h1>

<p>I’ve already built this example, and have hosted the image publicly in my <a href="https://hub.docker.com/r/scottcranton/helloworld-go">Docker Hub repository</a>.
To use Knative to serve up this existing image, you need to do the following command.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">--filename</span> service.yaml
</code></pre></div></div>

<p>Verify the domain URL for the service. It should be <code class="highlighter-rouge">helloworld-go.default.example.com</code>.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get kservice helloworld-go <span class="se">\</span>
  <span class="nt">--namespace</span> default <span class="se">\</span>
  <span class="nt">--output</span><span class="o">=</span>custom-columns<span class="o">=</span>NAME:.metadata.name,DOMAIN:.status.domain
</code></pre></div></div>

<p>And call the service. Note: the <code class="highlighter-rouge">curl --connect-to</code> option is only required when calling locally against minikube as
that option will add the correct host and sni headers to the request, and send the request to the host and port pair
returned from <code class="highlighter-rouge">glooctl proxy address</code>.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">--connect-to</span> helloworld-go.default.example.com:80:<span class="k">$(</span>glooctl proxy address <span class="nt">--name</span> clusteringress-proxy<span class="k">)</span> http://helloworld-go.default.example.com
</code></pre></div></div>

<p>To clean up, delete the resources.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl delete <span class="nt">--filename</span> service.yaml
</code></pre></div></div>

<h1 id="build-locally-and-deploy-using-knativeserving">Build locally, and deploy using Knative Serving</h1>

<p>Run <code class="highlighter-rouge">docker build</code> with your Docker Hub username.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">-t</span> <span class="k">${</span><span class="nv">DOCKER_USERNAME</span><span class="k">}</span>/helloworld-go <span class="nb">.</span>
docker push <span class="k">${</span><span class="nv">DOCKER_USERNAME</span><span class="k">}</span>/helloworld-go
</code></pre></div></div>

<p>Deploy the service. Again, make sure you updated username in <code class="highlighter-rouge">service.yaml</code> file, i.e., replace image reference
<code class="highlighter-rouge">docker.io/scottcranton/helloworld-go</code> with your Docker Hub username.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">--filename</span> service.yaml
</code></pre></div></div>

<p>Verify domain URL for service. Should be <code class="highlighter-rouge">helloworld-go.default.example.com</code>.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get kservice helloworld-go <span class="se">\</span>
  <span class="nt">--namespace</span> default <span class="se">\</span>
  <span class="nt">--output</span><span class="o">=</span>custom-columns<span class="o">=</span>NAME:.metadata.name,DOMAIN:.status.domain
</code></pre></div></div>

<p>And test your service.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">--connect-to</span> helloworld-go.default.example.com:80:<span class="k">$(</span>glooctl proxy address <span class="nt">--name</span> clusteringress-proxy<span class="k">)</span> http://helloworld-go.default.example.com
</code></pre></div></div>

<p>To clean up, delete the resources.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl delete <span class="nt">--filename</span> service.yaml
</code></pre></div></div>

<h1 id="build-using-knative-build-and-deploy-using-knativeserving">Build using Knative Build, and deploy using Knative Serving</h1>

<p>To install Knative Build, do the following. I’m using the <code class="highlighter-rouge">kaniko</code> build template, so you’ll also need to install that
as well.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="se">\</span>
  <span class="nt">--filename</span> https://github.com/knative/build/releases/download/v0.4.0/build.yaml

kubectl apply <span class="se">\</span>
  <span class="nt">--filename</span> https://raw.githubusercontent.com/knative/build-templates/master/kaniko/kaniko.yaml
</code></pre></div></div>

<p>To verify the Knative Build install, do the following.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pods <span class="nt">--namespace</span> knative-build
</code></pre></div></div>

<p>I’d encourage forking my example GitHub repository <a href="https://github.com/scranton/helloworld-knative">https://github.com/scranton/helloworld-knative</a>, so you can push
code changes and see them in your environment.</p>

<p>Create a Kubernetes secret for your Docker Hub account that will allow Knative build to push your image. You also need to annotate the secret to indicate it’s for Docker. More details in <a href="https://www.knative.dev/docs/build/auth/#guiding-credential-selection">Guiding credential selection</a>.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create secret generic basic-user-pass <span class="se">\</span>
  <span class="nt">--type</span><span class="o">=</span><span class="s2">"kubernetes.io/basic-auth"</span> <span class="se">\</span>
  <span class="nt">--from-literal</span><span class="o">=</span><span class="nv">username</span><span class="o">=</span><span class="k">${</span><span class="nv">DOCKER_USERNAME</span><span class="k">}</span> <span class="se">\</span>
  <span class="nt">--from-literal</span><span class="o">=</span><span class="nv">password</span><span class="o">=</span><span class="k">${</span><span class="nv">DOCKER_PASSWORD</span><span class="k">}</span>

kubectl annotate secret basic-user-pass <span class="se">\</span>
  build.knative.dev/docker-0<span class="o">=</span>https://index.docker.io/v1/
</code></pre></div></div>

<p>It should result in a secret like the following.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl describe secret basic-user-pass

Name:         basic-user-pass
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  build.knative.dev/docker-0: https://index.docker.io/v1/

Type:  kubernetes.io/basic-auth

Data
<span class="o">====</span>
username:  12 bytes
password:  24 bytes
</code></pre></div></div>

<p>Verify that <code class="highlighter-rouge">serviceaccount.yaml</code> references your secret.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ServiceAccount</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">build-bot</span>
<span class="na">secrets</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">basic-user-pass</span>
</code></pre></div></div>

<p>Update <code class="highlighter-rouge">service-build.yaml</code> with your GitHub and Docker usernames. This manifest will use Knative Build to create an
image using the <code class="highlighter-rouge">kaniko-build</code> build template and deploy the service using Knative Serving with Gloo.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">serving.knative.dev/v1alpha1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">helloworld-go</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">default</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">runLatest</span><span class="pi">:</span>
    <span class="na">configuration</span><span class="pi">:</span>
      <span class="na">build</span><span class="pi">:</span>
        <span class="na">apiVersion</span><span class="pi">:</span> <span class="s">build.knative.dev/v1alpha1</span>
        <span class="na">kind</span><span class="pi">:</span> <span class="s">Build</span>
        <span class="na">metadata</span><span class="pi">:</span>
          <span class="na">name</span><span class="pi">:</span> <span class="s">kaniko-build</span>
        <span class="na">spec</span><span class="pi">:</span>
          <span class="na">serviceAccountName</span><span class="pi">:</span> <span class="s">build-bot</span>
          <span class="na">source</span><span class="pi">:</span>
            <span class="na">git</span><span class="pi">:</span>
              <span class="na">url</span><span class="pi">:</span> <span class="s">https://github.com/{ GitHub username }/helloworld-knative</span>
              <span class="na">revision</span><span class="pi">:</span> <span class="s">master</span>
          <span class="na">template</span><span class="pi">:</span>
            <span class="na">name</span><span class="pi">:</span> <span class="s">kaniko</span>
            <span class="na">arguments</span><span class="pi">:</span>
              <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">IMAGE</span>
                <span class="na">value</span><span class="pi">:</span> <span class="s">docker.io/{ Docker Hub username }/helloworld-go</span>
          <span class="na">timeout</span><span class="pi">:</span> <span class="s">10m</span>
      <span class="na">revisionTemplate</span><span class="pi">:</span>
        <span class="na">spec</span><span class="pi">:</span>
          <span class="na">container</span><span class="pi">:</span>
            <span class="na">image</span><span class="pi">:</span> <span class="s">docker.io/{ Docker Hub username }/helloworld-go</span>
            <span class="na">imagePullPolicy</span><span class="pi">:</span> <span class="s">Always</span>
            <span class="na">env</span><span class="pi">:</span>
              <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">TARGET</span>
                <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Go</span><span class="nv"> </span><span class="s">Sample</span><span class="nv"> </span><span class="s">v1"</span>
</code></pre></div></div>

<p>To deploy, apply the manifests.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="se">\</span>
  <span class="nt">--filename</span> serviceaccount.yaml <span class="se">\</span>
  <span class="nt">--filename</span> service-build.yaml
</code></pre></div></div>

<p>Then you can watch the build and deployment happening.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pods <span class="nt">--watch</span>
</code></pre></div></div>

<p>Once you see all the <code class="highlighter-rouge">helloworld-go-0000x-deployment-....</code> pods are ready, then you can Ctrl+C to escape the watch, and
then test your deployment.</p>

<p>Verify the domain URL for service. Should be <code class="highlighter-rouge">helloworld-go.default.example.com</code>.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get kservice helloworld-go <span class="se">\</span>
  <span class="nt">--namespace</span> default <span class="se">\</span>
  <span class="nt">--output</span><span class="o">=</span>custom-columns<span class="o">=</span>NAME:.metadata.name,DOMAIN:.status.domain
</code></pre></div></div>

<p>And test your service.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">--connect-to</span> helloworld-go.default.example.com:80:<span class="k">$(</span>glooctl proxy address <span class="nt">--name</span> clusteringress-proxy<span class="k">)</span> http://helloworld-go.default.example.com
</code></pre></div></div>

<h2 id="cleanup">Cleanup</h2>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl delete <span class="se">\</span>
  <span class="nt">--filename</span> serviceaccount.yaml <span class="se">\</span>
  <span class="nt">--filename</span> service-build.yaml

kubectl delete secret basic-user-pass
</code></pre></div></div>

<h1 id="summary">Summary</h1>

<p>Hopefully, this post gave you a taste for how Gloo and Knative can work together to provide you with a way to build and
deploy your services on demand into Kubernetes.</p>

<h1 id="see-also">See Also</h1>

<ul>
  <li><a href="https://github.com/knative/docs/blob/master/install/getting-started-knative-app.md">https://github.com/knative/docs/blob/master/install/getting-started-knative-app.md</a></li>
  <li><a href="https://github.com/knative/docs">https://github.com/knative/docs</a></li>
  <li><a href="https://gloo.solo.io/getting_started/kubernetes/gloo_with_knative/">https://gloo.solo.io/getting_started/kubernetes/gloo_with_knative/</a></li>
</ul>


                
                    <p><a href="/knative-and-gloo.html" role="button">Read More</a></p>
                
            </div>

            <footer class="post-footer">
                <div class="share">Share
                    <ul class="social-networks">
                        <li class="share-facebook"><a href="https://www.facebook.com/sharer.php?s=100&p[title]=Automating your Services with Knative and Solo.io Gloo&p[summary]=Learn how Knative and Solo.io Gloo work together to support on demand code delivery in Kubernetes.&p[url]=https://scott.cranton.com/knative-and-gloo.html" class="s_facebook" target="_blank" onclick="window.open(this.href, '','width=700,height=300');return false;"><svg title="" width="16" height="16"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://scott.cranton.com/assets/svg/social-icons.svg#facebook-icon"></use></svg></a></a></li>
                        <li class="share-twitter"><a href="http://twitter.com/share?url=https://scott.cranton.com/knative-and-gloo.html&text=Learn how Knative and Solo.io Gloo work together to support on demand code delivery in Kubernetes.&hashtags=Gloo,Knative,Kubernetes," rel="noreferrer" target="_blank" onclick="window.open(this.href, '','width=700,height=300');return false;"><svg title="" width="16" height="16"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://scott.cranton.com/assets/svg/social-icons.svg#twitter-icon"></use></svg></a></li>
                    </ul>
                </div>
                
                <div class="tags">
                    <ul>
                        
                        <li><a href="https://scott.cranton.com/tag/Gloo">Gloo</a></li>
                        
                        <li><a href="https://scott.cranton.com/tag/Knative">Knative</a></li>
                        
                        <li><a href="https://scott.cranton.com/tag/Kubernetes">Kubernetes</a></li>
                        
                    </ul>
                </div>
                
            </footer>
        </article>
        
    

    
        
    
        
    
        
        <article class="post" role="article" itemscope itemtype="http://schema.org/BlogPosting">
            <header class="post-header">
                <ul>
                    <li><time datetime="2019-03-28T12:37:03-04:00" itemprop="datePublished">28 Mar, 2019</time></li>
                    
                </ul>
                <h2 itemprop="name headline"><a href="https://scott.cranton.com/kubernetes-ingress-controlling-with-gloo.html">Kubernetes Ingress Control using Gloo</a></h2>
            </header>

            <div class="post-content">
                <p>Kubernetes is excellent and makes it easier to create and manage highly distributed applications. A challenge then is how do you share your great Kubernetes hosted applications with the rest of the world. Many lean towards <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/">Kubernetes Ingress</a> objects and this article will show you how to use the open source <a href="https://solo.io">Solo.io</a> <a href="https://gloo.solo.io">Gloo</a> to fill this need.</p>

<p><img src="/assets/gloo_as_ingress.png" alt="Gloo as Ingress" /></p>

<p><a href="https://medium.com/solo-io/announcing-gloo-the-function-gateway-3f0860ef6600">Gloo is a function gateway</a> that gives users many benefits including sophisticated function level routing, and extensive service discovery with the introspection of OpenAPI (Swagger) definitions, gRPC reflection, Lambda discovery and more. Gloo can act as an Ingress Controller, that is, by routing Kubernetes external traffic to Kubernetes cluster hosted services based on the path routing rules defined in an Ingress Object. I’m a big believer in showing technology through examples, so let’s quickly run through an example to show you what’s possible.</p>

<h1 id="prerequisites">Prerequisites</h1>

<p>This example assumes you’re running on a local <a href="https://kubernetes.io/docs/setup/minikube/">minikube</a> instance, and that you also have <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/">kubectl</a> also running. You can run this same example on your favorite cloud provider managed Kubernetes cluster; you’d need to make a few tweaks. You’ll also need <a href="https://gloo.solo.io">Gloo</a> installed. Let’s use <a href="https://brew.sh/">Homebrew</a> to set all of this up for us, and then start minikube and install Gloo. It will take a few minutes to download and install everything to your local machine, and get everything started.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew update
brew cask <span class="nb">install </span>minikube
brew <span class="nb">install </span>kubectl glooctl curl

minikube start
glooctl <span class="nb">install </span>ingress
</code></pre></div></div>

<p>One more thing before we dive into Ingress objects, let’s set up an example service deployed on Kubernetes that we can reference.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="se">\</span>
  <span class="nt">--filename</span> https://raw.githubusercontent.com/solo-io/gloo/master/example/petstore/petstore.yaml
</code></pre></div></div>

<h1 id="setting-up-an-ingress-to-our-example-petstore">Setting up an Ingress to our example Petstore</h1>

<p>Let’s set up an Ingress object that routes all HTTP traffic to our petstore service. To make this a little more exciting and challenging, and who doesn’t like a good tech challenge, let’s also configure a host domain, which will require a little extra <code class="highlighter-rouge">curl</code> magic to call correctly on our local Kubernetes cluster. The following Ingress definition will route all requests to <code class="highlighter-rouge">http://gloo.example.com</code> to our petstore service listening on port 8080 within our cluster. The petstore service provides some REST functions listening on the query path <code class="highlighter-rouge">/api/pets</code> that will return JSON for the inventory of pets in our (small) store.</p>

<p>If you are trying this example in a public cloud Kubernetes instance, you’ll most likely need to configure a Cloud Load Balancer. Make sure you configure that Load Balancer for the <code class="highlighter-rouge">service/ingress-proxy</code> running in the <code class="highlighter-rouge">gloo-system</code> namespace.</p>

<p>The important details of our example Ingress definition are:</p>

<ul>
  <li>Annotation <code class="highlighter-rouge">kubernetes.io/ingress.class: gloo</code> which is the standard way to mark an Ingress object as handled by a specific Ingress controller, i.e., Gloo. This requirement will go away soon as we add the ability for Gloo to be the cluster default Ingress controller</li>
  <li>Path wildcard <code class="highlighter-rouge">/.*</code> to indicate that all traffic to <code class="highlighter-rouge">http://gloo.example.com</code> is routed to our petstore service</li>
</ul>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">cat &lt;&lt;EOF | kubectl apply --filename -</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">extensions/v1beta1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Ingress</span>
<span class="na">metadata</span><span class="pi">:</span>
 <span class="na">name</span><span class="pi">:</span> <span class="s">petstore-ingress</span>
 <span class="na">annotations</span><span class="pi">:</span>
    <span class="s">kubernetes.io/ingress.class</span><span class="pi">:</span> <span class="s">gloo</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">rules</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">host</span><span class="pi">:</span> <span class="s">gloo.example.com</span>
    <span class="na">http</span><span class="pi">:</span>
      <span class="na">paths</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">path</span><span class="pi">:</span> <span class="s">/.*</span>
        <span class="na">backend</span><span class="pi">:</span>
          <span class="na">serviceName</span><span class="pi">:</span> <span class="s">petstore</span>
          <span class="na">servicePort</span><span class="pi">:</span> <span class="s">8080</span>
<span class="s">EOF</span>
</code></pre></div></div>

<p>We can validate that Kubernetes created our Ingress correctly by the following command.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get ingress petstore-ingress

NAME               HOSTS              ADDRESS   PORTS   AGE
petstore-ingress   gloo.example.com             80      14h
</code></pre></div></div>

<p>To test we’ll use <code class="highlighter-rouge">curl</code> to call our local cluster. Like I said earlier, by defining a <code class="highlighter-rouge">host: gloo.example.com</code> in our Ingress, we need to do a little more to call this without doing things with DNS or our local /etc/hosts file. I’m going to use the recent <code class="highlighter-rouge">curl --connect-to</code> options, and you can read more about that at the <a href="https://curl.haxx.se/docs/manpage.html#--connect-to">curl man pages</a>.</p>

<p>The glooctl command-line tool helps us get the local host IP and port for the proxy with the <code class="highlighter-rouge">glooctl proxy address --name &lt;ingress name&gt; --port http</code> command. It returns the address (host IP:port) to the Gloo Ingress proxy that allows us external access to our local Kuberbetes cluster. If you are trying this example in a public cloud managed Kuberbetes, then most will handle the DNS mapping for your specified domain (that you should own), and the Gloo Ingress service, so in that case, you do NOT need the <code class="highlighter-rouge">--connect-to</code> magic, just <code class="highlighter-rouge">curl http://gloo.example.com/api/pets</code> should work.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">--connect-to</span> gloo.example.com:80:<span class="k">$(</span>glooctl proxy address <span class="nt">--name</span> ingress-proxy <span class="nt">--port</span> http<span class="k">)</span> <span class="se">\</span>
    http://gloo.example.com/api/pets
</code></pre></div></div>

<p>Which should return the following JSON</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[{</span><span class="s2">"id"</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="s2">"name"</span><span class="p">:</span><span class="s2">"Dog"</span><span class="p">,</span><span class="s2">"status"</span><span class="p">:</span><span class="s2">"available"</span><span class="p">},{</span><span class="s2">"id"</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="s2">"name"</span><span class="p">:</span><span class="s2">"Cat"</span><span class="p">,</span><span class="s2">"status"</span><span class="p">:</span><span class="s2">"pending"</span><span class="p">}]</span><span class="w">
</span></code></pre></div></div>

<h1 id="tls-configuration">TLS Configuration</h1>

<p>These days, most want to use TLS to secure your communications. Gloo Ingress can act as a TLS terminator, and we’ll quickly run through what that set up would look like.</p>

<p>Any Kubernetes Ingress doing TLS will need a Kubernetes TLS secret created, so let’s create a self-signed certificate we can use for our example <code class="highlighter-rouge">gloo.example.com</code> domain. The following two commands will produce a certificate and generate a TLS secret named <code class="highlighter-rouge">my-tls-secret</code> in minikube.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl req <span class="nt">-x509</span> <span class="nt">-nodes</span> <span class="nt">-days</span> 365 <span class="nt">-newkey</span> rsa:2048 <span class="nt">-keyout</span> my_key.key <span class="nt">-out</span> my_cert.cert <span class="nt">-subj</span> <span class="s2">"/CN=gloo.example.com/O=gloo.example.com"</span>

kubectl create secret tls my-tls-secret <span class="nt">--key</span> my_key.key <span class="nt">--cert</span> my_cert.cert
</code></pre></div></div>

<p>Now let’s update our Ingress object with the needed TLS configuration. Important that the TLS host and the rules host match, and the <code class="highlighter-rouge">secretName</code> matches the name of the Kubernetes secret deployed previously.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">cat &lt;&lt;EOF | kubectl apply --filename -</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">extensions/v1beta1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Ingress</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">petstore-ingress</span>
  <span class="na">annotations</span><span class="pi">:</span>
    <span class="s">kubernetes.io/ingress.class</span><span class="pi">:</span> <span class="s">gloo</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">tls</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">hosts</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">gloo.example.com</span>
    <span class="na">secretName</span><span class="pi">:</span> <span class="s">my-tls-secret</span>
  <span class="na">rules</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">host</span><span class="pi">:</span> <span class="s">gloo.example.com</span>
    <span class="na">http</span><span class="pi">:</span>
      <span class="na">paths</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">path</span><span class="pi">:</span> <span class="s">/.*</span>
        <span class="na">backend</span><span class="pi">:</span>
          <span class="na">serviceName</span><span class="pi">:</span> <span class="s">petstore</span>
          <span class="na">servicePort</span><span class="pi">:</span> <span class="s">8080</span>
<span class="s">EOF</span>
</code></pre></div></div>

<p>If all went well, we should have changed our petstore to now be listening to <code class="highlighter-rouge">https://gloo.example.com</code>. Let’s try it, again using our curl magic, which we need to both resolve the host and port as well as to validate our certificate. Notice that we’re asking glooctl for <code class="highlighter-rouge">--port https</code> this time, and we’re curling <code class="highlighter-rouge">https://gloo.example.com</code> on port 443. We’ll also have curl validate our TLS certificate using <code class="highlighter-rouge">curl --cacert &lt;my_cert.cert&gt;</code> with the certificate we created and used in our Kubernetes secret.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">--cacert</span> my_cert.cert <span class="se">\</span>
    <span class="nt">--connect-to</span> gloo.example.com:443:<span class="k">$(</span>glooctl proxy address <span class="nt">--name</span> ingress-proxy <span class="nt">--port</span> https<span class="k">)</span> <span class="se">\</span>
    https://gloo.example.com/api/pets
</code></pre></div></div>

<h1 id="next-steps">Next Steps</h1>

<p>This was a quick tour of how Gloo can act as your Kubernetes Ingress controller making very minimal changes to your existing Kubernetes manifests. Please try it out and let us know what you think at our <a href="https://slack.solo.io/">community Slack channel</a>.</p>

<p>If you’re interested in powering up you Gloo superpowers, try Gloo in gateway mode <code class="highlighter-rouge">glooctl install gateway</code>, which unlocks a set of Kubernetes CRDs (Custom Resources) that give you a more standard, and far more powerful, way of doing more advanced traffic shifting, rate limiting, and more without the annotation smell in your Kubernetes cluster. Check out these other articles for more details on Gloo’s extra powers.</p>

<ul>
  <li><a href="/function-routing-with-gloo.html">Routing with Gloo Function Gateway</a></li>
  <li><a href="/canary-deployments-with-solo.html">Canary Deployments with Gloo Function Gateway</a></li>
  <li><a href="/canary-deployments-with-weighted-routes.html">Canary Deployments with Gloo Function Gateway using Weighted Destinations</a></li>
</ul>


                
                    <p><a href="/kubernetes-ingress-controlling-with-gloo.html" role="button">Read More</a></p>
                
            </div>

            <footer class="post-footer">
                <div class="share">Share
                    <ul class="social-networks">
                        <li class="share-facebook"><a href="https://www.facebook.com/sharer.php?s=100&p[title]=Kubernetes Ingress Control using Gloo&p[summary]=Setting up Gloo to be your Kubernetes Ingress controller&p[url]=https://scott.cranton.com/kubernetes-ingress-controlling-with-gloo.html" class="s_facebook" target="_blank" onclick="window.open(this.href, '','width=700,height=300');return false;"><svg title="" width="16" height="16"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://scott.cranton.com/assets/svg/social-icons.svg#facebook-icon"></use></svg></a></a></li>
                        <li class="share-twitter"><a href="http://twitter.com/share?url=https://scott.cranton.com/kubernetes-ingress-controlling-with-gloo.html&text=Setting up Gloo to be your Kubernetes Ingress controller&hashtags=Gloo,Ingress,Kubernetes," rel="noreferrer" target="_blank" onclick="window.open(this.href, '','width=700,height=300');return false;"><svg title="" width="16" height="16"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://scott.cranton.com/assets/svg/social-icons.svg#twitter-icon"></use></svg></a></li>
                    </ul>
                </div>
                
                <div class="tags">
                    <ul>
                        
                        <li><a href="https://scott.cranton.com/tag/Gloo">Gloo</a></li>
                        
                        <li><a href="https://scott.cranton.com/tag/Ingress">Ingress</a></li>
                        
                        <li><a href="https://scott.cranton.com/tag/Kubernetes">Kubernetes</a></li>
                        
                    </ul>
                </div>
                
            </footer>
        </article>
        
    

    
        
    
        
    

    
        
    
        
    

    
        
    

    

    

    

    

    
        
    
        
    

    

    

    
        
    
        
    

    

    
        
    

    
        
    

            </main>
        </div>

        <script src="https://scott.cranton.com/assets/js/jquery-1.12.2.min.js"></script>
<script src="https://scott.cranton.com/assets/js/backtotop.js"></script>
<script src="https://scott.cranton.com/assets/js/lunr.min.js"></script>
<script src="https://scott.cranton.com/assets/js/lunr-feed.js"></script>
<script src="https://scott.cranton.com/assets/js/jquery.fitvids.js"></script>
<script src="https://scott.cranton.com/assets/js/svg4everybody.min.js"></script>
<script src="https://scott.cranton.com/assets/js/scripts.js"></script>


    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-134627391-1', 'auto');
        ga('send', 'pageview');
    </script>

    </body>
</html>